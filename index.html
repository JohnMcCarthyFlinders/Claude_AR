<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest AR GLB Viewer - Fixed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Load GLTFLoader after THREE.js is loaded
        const script = document.createElement('script');
        script.src = 'https://threejs.org/examples/js/loaders/GLTFLoader.js';
        script.onload = () => {
            console.log('GLTFLoader loaded successfully');
            // Initialize the viewer after GLTFLoader is loaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initViewer);
            } else {
                initViewer();
            }
        };
        script.onerror = () => {
            console.error('Failed to load GLTFLoader');
            document.getElementById('status').textContent = 'Failed to load GLTFLoader';
        };
        document.head.appendChild(script);
        
        function initViewer() {
            console.log('=== AR VIEWER DEBUG START ===');
            console.log('THREE.js version:', THREE.REVISION);
            console.log('GLTFLoader available:', typeof THREE.GLTFLoader !== 'undefined');
            
            try {
                const viewer = new QuestARViewer();
                console.log('QuestARViewer initialized successfully');
            } catch (error) {
                console.error('Failed to initialize QuestARViewer:', error);
                document.getElementById('status').textContent = 'Initialization failed - check console';
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
        }
        
        #modelSelect {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border-radius: 5px;
            border: none;
            background: white;
        }
        
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
        
        .controls {
            margin-top: 10px;
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 4px;
            border: none;
            border-radius: 3px;
            margin: 0 5px;
        }
        
        .lighting-controls {
            margin-top: 15px;
            border-top: 1px solid #444;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h3>Quest AR GLB Viewer</h3>
            
            <select id="modelSelect">
                <option value="">Select a model...</option>
            </select>
            
            <div class="controls">
                <button id="enterAR">Enter AR</button>
                <button id="resetPosition">Reset Position</button>
                <button id="toggleAnimation">Play/Pause Animation</button>
            </div>
            
            <div class="control-group">
                <label>Scale: <span id="scaleValue">1.0</span></label>
                <input type="range" id="scaleSlider" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>Height Offset (m):</label>
                <input type="number" id="heightOffset" value="0" step="0.1" min="-2" max="2">
            </div>
            
            <div class="lighting-controls">
                <label>Ambient Light: <span id="ambientValue">0.6</span></label>
                <input type="range" id="ambientSlider" min="0.1" max="2.0" step="0.1" value="0.6">
                
                <label>Directional Light: <span id="directionalValue">0.8</span></label>
                <input type="range" id="directionalSlider" min="0.1" max="2.0" step="0.1" value="0.8">
            </div>
            
            <div id="status">Ready to load model</div>
        </div>
    </div>

    <script>
        class QuestARViewer {
            constructor() {
                console.log('=== QuestARViewer Constructor Start ===');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.currentModel = null;
                this.mixer = null;
                this.clock = new THREE.Clock();
                this.isARSupported = false;
                this.isInAR = false;
                this.animationActions = [];
                
                this.init();
                this.setupEventListeners();
                this.loadAvailableModels();
                console.log('=== QuestARViewer Constructor End ===');
            }
            
            enhanceMaterial(material) {
                // Handle different material types with balanced lighting
                if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                    console.log('Enhancing PBR material:', {
                        metalness: material.metalness,
                        roughness: material.roughness,
                        envMapIntensity: material.envMapIntensity
                    });
                    
                    // Tone down metallic reflections that were too bright
                    if (material.metalness > 0.5) {
                        material.envMap = this.scene.environment;
                        material.envMapIntensity = Math.min(material.envMapIntensity || 1, 0.8); // Reduced from 1.5
                        material.metalness = Math.min(material.metalness, 0.8); // Reduce extreme metalness
                        console.log('Applied balanced environment map to metallic material');
                    }
                    
                    // Increase roughness slightly to reduce harsh reflections
                    if (material.roughness < 0.2) {
                        material.roughness = Math.max(material.roughness, 0.2); // Increased from 0.05
                    }
                    
                    // Brighten diffuse materials that were too dark
                    if (material.color && material.color.getHSL) {
                        const hsl = { h: 0, s: 0, l: 0 };
                        material.color.getHSL(hsl);
                        if (hsl.l < 0.4) { // Increased threshold from 0.3
                            material.color.setHSL(hsl.h, hsl.s, Math.max(hsl.l, 0.5)); // Brighter minimum
                            console.log('Brightened dark diffuse material');
                        }
                    }
                }
                
                // For basic materials, convert to standard material with better balance
                else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial) {
                    console.log('Converting basic material to standard');
                    const standardMaterial = new THREE.MeshStandardMaterial({
                        color: material.color,
                        map: material.map,
                        normalMap: material.normalMap,
                        envMap: this.scene.environment,
                        envMapIntensity: 0.2, // Reduced from 0.3
                        metalness: 0.05,      // Reduced from 0.1
                        roughness: 0.8        // Increased from 0.7
                    });
                    
                    return standardMaterial;
                }
                
                material.needsUpdate = true;
                return material;
            }
            
            init() {
                console.log('Initializing renderer...');
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.xr.enabled = true;
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Enable tone mapping for better exposure control
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // Setup camera
                this.camera.position.set(0, 1.6, 3);
                
                // Basic mouse controls
                this.setupBasicControls();
                
                // Setup balanced lighting
                this.setupLighting();
                
                // Check AR support
                this.checkARSupport();
                
                // Start render loop
                this.renderer.setAnimationLoop(this.render.bind(this));
                console.log('Renderer initialized successfully');
            }
            
            setupBasicControls() {
                console.log('Setting up basic mouse controls...');
                let isMouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown || this.isInAR) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    if (this.isInAR) return;
                    
                    const zoom = e.deltaY > 0 ? 1.1 : 0.9;
                    this.camera.position.multiplyScalar(zoom);
                });
                console.log('Basic controls setup complete');
            }
            
            setupLighting() {
                console.log('Setting up balanced lighting...');
                
                // Increased ambient light for better diffuse illumination
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Increased from 0.4
                this.scene.add(this.ambientLight);
                
                // Reduced directional light to prevent overexposure on reflective materials
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Reduced from 0.8
                this.directionalLight.position.set(5, 10, 5);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 50;
                this.scene.add(this.directionalLight);
                
                // Softer fill lights
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.2); // Reduced from 0.3
                fillLight.position.set(-5, 5, -5);
                this.scene.add(fillLight);
                
                // Reduced point light intensity
                const pointLight = new THREE.PointLight(0xffffff, 0.4, 100); // Reduced from 0.6
                pointLight.position.set(0, 5, 0);
                this.scene.add(pointLight);
                
                // Create a more neutral environment map
                this.createEnvironmentMap();
                
                console.log('Balanced lighting setup complete');
            }
            
            createEnvironmentMap() {
                console.log('Creating neutral environment map...');
                
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const context = canvas.getContext('2d');
                
                // Create a more neutral gradient
                const gradient = context.createLinearGradient(0, 0, 0, 256);
                gradient.addColorStop(0, '#B0C4DE');    // Light steel blue (less intense)
                gradient.addColorStop(0.5, '#F5F5F5');  // White smoke (softer than pure white)
                gradient.addColorStop(1, '#DCDCDC');    // Gainsboro (neutral gray)
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, 256, 256);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.mapping = THREE.EquirectangularReflectionMapping;
                
                this.scene.environment = texture;
                this.scene.background = null; // Keep transparent for AR
                
                console.log('Neutral environment map created');
            }
            
            async checkARSupport() {
                if ('xr' in navigator) {
                    try {
                        this.isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
                        const enterARButton = document.getElementById('enterAR');
                        
                        if (this.isARSupported) {
                            enterARButton.disabled = false;
                            this.updateStatus('AR supported! Load a model and click Enter AR');
                        } else {
                            enterARButton.disabled = true;
                            this.updateStatus('AR not supported on this device');
                        }
                    } catch (error) {
                        console.error('Error checking AR support:', error);
                        this.updateStatus('Error checking AR support');
                    }
                } else {
                    this.updateStatus('WebXR not supported');
                }
            }
            
            async loadAvailableModels() {
                console.log('Loading available models...');
                
                // Working sample models with correct URLs
                const workingModels = [
                    { 
                        name: 'Avocado (Khronos)', 
                        path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF-Binary/Avocado.glb' 
                    },
                    { 
                        name: 'Box Textured (Khronos)', 
                        path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoxTextured/glTF-Binary/BoxTextured.glb' 
                    },
                    { 
                        name: 'Duck (Khronos)', 
                        path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb' 
                    },
                    { 
                        name: 'Flight Helmet (Khronos)', 
                        path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/FlightHelmet/glTF-Binary/FlightHelmet.glb' 
                    }
                ];
                
                // Your local files
                const localFiles = [
                    { name: 'B (Local)', path: './models/b.glb' },
                    { name: 'C (Local)', path: './models/c.glb' },
                    { name: 'T (Local)', path: './models/t.glb' }
                ];
                
                const select = document.getElementById('modelSelect');
                
                // Add working models first
                workingModels.forEach((model) => {
                    const option = document.createElement('option');
                    option.value = model.path;
                    option.textContent = model.name;
                    select.appendChild(option);
                });
                
                // Add local models
                localFiles.forEach((model) => {
                    const option = document.createElement('option');
                    option.value = model.path;
                    option.textContent = model.name + ' (Check if file exists)';
                    select.appendChild(option);
                });
                
                this.updateStatus(`Ready! Try the Khronos sample models first`);
            }
            
            async loadModel(url) {
                if (!url) return;
                
                console.log('Loading model:', url);
                this.updateStatus('Loading model...');
                
                try {
                    // Remove existing model
                    if (this.currentModel) {
                        this.scene.remove(this.currentModel);
                    }
                    
                    // Stop existing animations
                    if (this.mixer) {
                        this.mixer.stopAllAction();
                    }
                    
                    const loader = new THREE.GLTFLoader();
                    
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load(url, 
                            (gltf) => resolve(gltf), 
                            (progress) => {
                                const percent = Math.round(progress.loaded / progress.total * 100);
                                this.updateStatus(`Loading... ${percent}%`);
                            }, 
                            (error) => reject(error)
                        );
                    });
                    
                    this.currentModel = gltf.scene;
                    
                    // Setup model with balanced materials
                    this.currentModel.position.set(0, 0, -2);
                    this.currentModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Enhance materials with balanced approach
                            if (child.material) {
                                const enhanced = this.enhanceMaterial(child.material);
                                if (enhanced !== child.material) {
                                    child.material = enhanced;
                                }
                            }
                        }
                    });
                    
                    // Setup animations
                    if (gltf.animations && gltf.animations.length > 0) {
                        this.mixer = new THREE.AnimationMixer(this.currentModel);
                        this.animationActions = [];
                        
                        gltf.animations.forEach((clip) => {
                            const action = this.mixer.clipAction(clip);
                            this.animationActions.push(action);
                            action.play();
                        });
                        
                        document.getElementById('toggleAnimation').disabled = false;
                    } else {
                        document.getElementById('toggleAnimation').disabled = true;
                    }
                    
                    this.scene.add(this.currentModel);
                    this.updateStatus(`Model loaded: ${url.split('/').pop()}`);
                    
                } catch (error) {
                    console.error('Error loading model:', error);
                    this.updateStatus(`Error: ${error.message}`);
                }
            }
            
            updateLighting() {
                const ambientValue = parseFloat(document.getElementById('ambientSlider').value);
                const directionalValue = parseFloat(document.getElementById('directionalSlider').value);
                
                this.ambientLight.intensity = ambientValue;
                this.directionalLight.intensity = directionalValue;
                
                document.getElementById('ambientValue').textContent = ambientValue.toFixed(1);
                document.getElementById('directionalValue').textContent = directionalValue.toFixed(1);
            }
            
            async enterAR() {
                if (!this.isARSupported || !this.currentModel) return;
                
                try {
                    const session = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['local-floor'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.getElementById('ui') }
                    });
                    
                    this.renderer.xr.setSession(session);
                    this.isInAR = true;
                    
                    this.resetModelPosition();
                    this.updateStatus('AR session active');
                    
                    session.addEventListener('end', () => {
                        this.isInAR = false;
                        this.updateStatus('AR session ended');
                    });
                    
                } catch (error) {
                    console.error('Error entering AR:', error);
                    this.updateStatus('Failed to enter AR');
                }
            }
            
            resetModelPosition() {
                if (!this.currentModel) return;
                
                const heightOffset = parseFloat(document.getElementById('heightOffset').value);
                
                if (this.isInAR) {
                    this.currentModel.position.set(0, heightOffset, -1.5);
                } else {
                    this.currentModel.position.set(0, heightOffset, -2);
                }
                
                this.currentModel.rotation.set(0, 0, 0);
            }
            
            updateScale() {
                if (!this.currentModel) return;
                
                const scale = parseFloat(document.getElementById('scaleSlider').value);
                this.currentModel.scale.setScalar(scale);
                document.getElementById('scaleValue').textContent = scale.toFixed(1);
            }
            
            toggleAnimation() {
                if (!this.mixer || this.animationActions.length === 0) return;
                
                const isPlaying = this.animationActions.some(action => action.isRunning());
                
                this.animationActions.forEach(action => {
                    if (isPlaying) {
                        action.pause();
                    } else {
                        action.play();
                    }
                });
            }
            
            setupEventListeners() {
                document.getElementById('modelSelect').addEventListener('change', (e) => {
                    this.loadModel(e.target.value);
                });
                
                document.getElementById('enterAR').addEventListener('click', () => {
                    this.enterAR();
                });
                
                document.getElementById('resetPosition').addEventListener('click', () => {
                    this.resetModelPosition();
                });
                
                document.getElementById('toggleAnimation').addEventListener('click', () => {
                    this.toggleAnimation();
                });
                
                document.getElementById('scaleSlider').addEventListener('input', () => {
                    this.updateScale();
                });
                
                document.getElementById('heightOffset').addEventListener('change', () => {
                    this.resetModelPosition();
                });
                
                // Lighting controls
                document.getElementById('ambientSlider').addEventListener('input', () => {
                    this.updateLighting();
                });
                
                document.getElementById('directionalSlider').addEventListener('input', () => {
                    this.updateLighting();
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }
            
            render() {
                if (this.mixer) {
                    const delta = this.clock.getDelta();
                    this.mixer.update(delta);
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // QuestARViewer class definition - will be initialized after GLTFLoader loads
    </script>
</body>
</html>
