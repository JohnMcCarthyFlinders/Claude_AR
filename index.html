<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest AR GLB Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
        }
        
        #modelSelect {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border-radius: 5px;
            border: none;
            background: white;
        }
        
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
        
        .controls {
            margin-top: 10px;
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 4px;
            border: none;
            border-radius: 3px;
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h3>Quest AR GLB Viewer</h3>
            
            <select id="modelSelect">
                <option value="">Select a model...</option>
            </select>
            
            <div class="controls">
                <button id="enterAR">Enter AR</button>
                <button id="resetPosition">Reset Position</button>
                <button id="toggleAnimation">Play/Pause Animation</button>
            </div>
            
            <div class="control-group">
                <label>Scale: <span id="scaleValue">1.0</span></label>
                <input type="range" id="scaleSlider" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>Height Offset (m):</label>
                <input type="number" id="heightOffset" value="0" step="0.1" min="-2" max="2">
            </div>
            
            <div id="status">Ready to load model</div>
        </div>
    </div>

    <script>
        class QuestARViewer {
            constructor() {
                console.log('=== QuestARViewer Constructor Start ===');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.currentModel = null;
                this.mixer = null;
                this.clock = new THREE.Clock();
                this.isARSupported = false;
                this.isInAR = false;
                this.animationActions = [];
                
                this.init();
                this.setupEventListeners();
                this.loadAvailableModels();
                console.log('=== QuestARViewer Constructor End ===');
            }
            
            init() {
                console.log('Initializing renderer...');
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.xr.enabled = true;
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // Setup camera
                this.camera.position.set(0, 1.6, 3);
                
                // Basic mouse controls (NO OrbitControls)
                this.setupBasicControls();
                
                // Setup lighting
                this.setupLighting();
                
                // Check AR support
                this.checkARSupport();
                
                // Start render loop
                this.renderer.setAnimationLoop(this.render.bind(this));
                console.log('Renderer initialized successfully');
            }
            
            setupBasicControls() {
                console.log('Setting up basic mouse controls...');
                // Simple mouse controls without any external dependencies
                let isMouseDown = false;
                let mouseX = 0;
                let mouseY = 0;
                
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown || this.isInAR) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    this.camera.position.x += deltaX * 0.01;
                    this.camera.position.y -= deltaY * 0.01;
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    if (this.isInAR) return;
                    
                    const zoom = e.deltaY > 0 ? 1.1 : 0.9;
                    this.camera.position.multiplyScalar(zoom);
                });
                console.log('Basic controls setup complete');
            }
            
            setupLighting() {
                console.log('Setting up enhanced lighting...');
                
                // Increased ambient light for better base illumination
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);
                
                // Main directional light (sun-like)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                this.scene.add(directionalLight);
                
                // Secondary directional light from opposite side for fill lighting
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
                fillLight.position.set(-5, 5, -5);
                this.scene.add(fillLight);
                
                // Bright point light for additional model illumination
                const pointLight = new THREE.PointLight(0xffffff, 1.0, 100);
                pointLight.position.set(0, 5, 0);
                this.scene.add(pointLight);
                
                // Additional point lights around the model for even coverage
                const sideLight1 = new THREE.PointLight(0xffffff, 0.7, 50);
                sideLight1.position.set(3, 2, 3);
                this.scene.add(sideLight1);
                
                const sideLight2 = new THREE.PointLight(0xffffff, 0.7, 50);
                sideLight2.position.set(-3, 2, -3);
                this.scene.add(sideLight2);
                
                // Store lights for potential runtime adjustment
                this.lights = {
                    ambient: ambientLight,
                    directional: directionalLight,
                    fill: fillLight,
                    point: pointLight,
                    side1: sideLight1,
                    side2: sideLight2
                };
                
                console.log('Enhanced lighting setup complete');
            }
            
            async checkARSupport() {
                if ('xr' in navigator) {
                    try {
                        this.isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
                        const enterARButton = document.getElementById('enterAR');
                        
                        if (this.isARSupported) {
                            enterARButton.disabled = false;
                            this.updateStatus('AR supported! Load a model and click Enter AR');
                        } else {
                            enterARButton.disabled = true;
                            this.updateStatus('AR not supported on this device');
                        }
                    } catch (error) {
                        console.error('Error checking AR support:', error);
                        this.updateStatus('Error checking AR support');
                    }
                } else {
                    this.updateStatus('WebXR not supported');
                }
            }
            
            async loadAvailableModels() {
                console.log('Loading available models...');
                
                // Option 1: Your local files (currently only 2 bytes - corrupted)
                const localFiles = [
                    { name: 'B (Local)', path: './models/b.glb' },
                    { name: 'C (Local)', path: './models/c.glb' },
                    { name: 'T (Local)', path: './models/t.glb' }
                ];
                
                // Option 2: Sample models from web for testing
                const sampleFiles = [
                    { name: 'Duck (Sample)', path: 'https://threejs.org/examples/models/gltf/Duck/glTF-Binary/Duck.glb' },
                    { name: 'Helmet (Sample)', path: 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF-Binary/DamagedHelmet.glb' },
                    { name: 'Fox (Sample)', path: 'https://threejs.org/examples/models/gltf/Fox/glTF-Binary/Fox.glb' }
                ];
                
                const select = document.getElementById('modelSelect');
                
                try {
                    console.log('Adding sample models for testing...');
                    
                    // Add sample models first (these will work)
                    sampleFiles.forEach((model, index) => {
                        const option = document.createElement('option');
                        option.value = model.path;
                        option.textContent = model.name;
                        select.appendChild(option);
                        console.log(`Added sample ${index + 1}: ${model.name} -> ${model.path}`);
                    });
                    
                    // Add local models (for when you fix them)
                    localFiles.forEach((model, index) => {
                        const option = document.createElement('option');
                        option.value = model.path;
                        option.textContent = model.name + ' (Fix needed)';
                        select.appendChild(option);
                        console.log(`Added local ${index + 1}: ${model.name} -> ${model.path}`);
                    });
                    
                    console.log('Select element now has', select.options.length, 'options');
                    this.updateStatus(`Found ${sampleFiles.length} working samples + ${localFiles.length} local files. Try the samples first!`);
                } catch (error) {
                    console.error('Error loading model list:', error);
                    this.updateStatus('Error loading model list - check console');
                }
            }
            
            async loadModel(url) {
                if (!url) return;
                
                console.log('Loading model:', url);
                this.updateStatus('Loading model...');
                
                try {
                    // First, test if the file exists and get its size
                    console.log('Testing file access...');
                    const response = await fetch(url);
                    console.log('Fetch response:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const contentLength = response.headers.get('content-length');
                    console.log('Content-Length:', contentLength);
                    
                    const blob = await response.blob();
                    console.log('File size:', blob.size, 'bytes');
                    
                    if (blob.size === 0) {
                        throw new Error('File is empty');
                    }
                    
                    if (blob.size < 100) {
                        throw new Error('File suspiciously small - might be corrupted');
                    }
                    
                    // Remove existing model
                    if (this.currentModel) {
                        this.scene.remove(this.currentModel);
                    }
                    
                    // Stop existing animations
                    if (this.mixer) {
                        this.mixer.stopAllAction();
                    }
                    
                    console.log('Creating GLTFLoader...');
                    const loader = new THREE.GLTFLoader();
                    
                    console.log('Loading GLB file...');
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load(url, 
                            (gltf) => {
                                console.log('GLB loaded successfully', gltf);
                                resolve(gltf);
                            }, 
                            (progress) => {
                                console.log('Loading progress:', Math.round(progress.loaded / progress.total * 100) + '%');
                            }, 
                            (error) => {
                                console.error('GLTFLoader error:', error);
                                reject(error);
                            }
                        );
                    });
                    
                    this.currentModel = gltf.scene;
                    console.log('Model scene:', this.currentModel);
                    
                    // Setup model
                    this.currentModel.position.set(0, 0, -2);
                    this.currentModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            console.log('Found mesh:', child.name || 'unnamed');
                        }
                    });
                    
                    // Setup animations
                    if (gltf.animations && gltf.animations.length > 0) {
                        console.log('Found animations:', gltf.animations.length);
                        this.mixer = new THREE.AnimationMixer(this.currentModel);
                        this.animationActions = [];
                        
                        gltf.animations.forEach((clip) => {
                            const action = this.mixer.clipAction(clip);
                            this.animationActions.push(action);
                            action.play();
                        });
                        
                        document.getElementById('toggleAnimation').disabled = false;
                    } else {
                        console.log('No animations found');
                        document.getElementById('toggleAnimation').disabled = true;
                    }
                    
                    this.scene.add(this.currentModel);
                    this.updateStatus(`Model loaded: ${url.split('/').pop()}`);
                    console.log('Model added to scene successfully');
                    
                } catch (error) {
                    console.error('Detailed error loading model:', {
                        error: error,
                        message: error.message,
                        stack: error.stack,
                        url: url
                    });
                    this.updateStatus(`Error: ${error.message}`);
                }
            }
            
            async enterAR() {
                if (!this.isARSupported || !this.currentModel) return;
                
                try {
                    const session = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['local-floor'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.getElementById('ui') }
                    });
                    
                    this.renderer.xr.setSession(session);
                    this.isInAR = true;
                    
                    // Position model in AR space
                    this.resetModelPosition();
                    
                    this.updateStatus('AR session active');
                    
                    session.addEventListener('end', () => {
                        this.isInAR = false;
                        this.updateStatus('AR session ended');
                    });
                    
                } catch (error) {
                    console.error('Error entering AR:', error);
                    this.updateStatus('Failed to enter AR');
                }
            }
            
            resetModelPosition() {
                if (!this.currentModel) return;
                
                const heightOffset = parseFloat(document.getElementById('heightOffset').value);
                
                if (this.isInAR) {
                    // Position model in front of user in AR
                    this.currentModel.position.set(0, heightOffset, -1.5);
                } else {
                    // Position model for desktop viewing
                    this.currentModel.position.set(0, heightOffset, -2);
                }
                
                this.currentModel.rotation.set(0, 0, 0);
            }
            
            updateScale() {
                if (!this.currentModel) return;
                
                const scale = parseFloat(document.getElementById('scaleSlider').value);
                this.currentModel.scale.setScalar(scale);
                document.getElementById('scaleValue').textContent = scale.toFixed(1);
            }
            
            toggleAnimation() {
                if (!this.mixer || this.animationActions.length === 0) return;
                
                const isPlaying = this.animationActions.some(action => action.isRunning());
                
                this.animationActions.forEach(action => {
                    if (isPlaying) {
                        action.pause();
                    } else {
                        action.play();
                    }
                });
            }
            
            setupEventListeners() {
                // Model selection
                document.getElementById('modelSelect').addEventListener('change', (e) => {
                    this.loadModel(e.target.value);
                });
                
                // AR controls
                document.getElementById('enterAR').addEventListener('click', () => {
                    this.enterAR();
                });
                
                document.getElementById('resetPosition').addEventListener('click', () => {
                    this.resetModelPosition();
                });
                
                document.getElementById('toggleAnimation').addEventListener('click', () => {
                    this.toggleAnimation();
                });
                
                // Scale control
                document.getElementById('scaleSlider').addEventListener('input', () => {
                    this.updateScale();
                });
                
                // Height offset
                document.getElementById('heightOffset').addEventListener('change', () => {
                    this.resetModelPosition();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }
            
            render() {
                // Update animations
                if (this.mixer) {
                    const delta = this.clock.getDelta();
                    this.mixer.update(delta);
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the AR viewer when page loads
        window.addEventListener('load', () => {
            console.log('=== AR VIEWER DEBUG START ===');
            console.log('THREE.js version:', THREE.REVISION);
            console.log('GLTFLoader available:', typeof THREE.GLTFLoader !== 'undefined');
            console.log('WebGL supported:', !!window.WebGLRenderingContext);
            
            try {
                const viewer = new QuestARViewer();
                console.log('QuestARViewer initialized successfully');
            } catch (error) {
                console.error('Failed to initialize QuestARViewer:', error);
                document.getElementById('status').textContent = 'Initialization failed - check console';
            }
            
            console.log('=== AR VIEWER DEBUG END ===');
        });
    </script>
</body>
</html>
